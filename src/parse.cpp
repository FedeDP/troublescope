#include "plugin.h"

//////////////////////////
// Parse capability
//////////////////////////

// We need to parse only the async events produced by this plugin. The async
// events produced by this plugin are injected in the syscall event source,
// so here we need to parse events coming from the "syscall" source.
// We will select specific events to parse through the
// `get_parse_event_types` API.
std::vector<std::string> my_plugin::get_parse_event_sources() {
	return PARSE_EVENT_SOURCES;
}

std::vector<falcosecurity::event_type> my_plugin::get_parse_event_types() {
	return PARSE_EVENT_CODES;
}

bool my_plugin::parse_async_event(const falcosecurity::parse_event_input &in) {
	auto &evt = in.get_event_reader();
	falcosecurity::events::asyncevent_e_decoder ad(evt);

	falcosecurity::events::asyncevent_e_decoder dec(in.get_event_reader());

	bool is_root = std::strcmp(ad.get_name(), ASYNC_EVENT_ROOT_NAME) == 0;
	bool is_pid = std::strcmp(ad.get_name(), ASYNC_EVENT_PID_NAME) == 0;
	bool is_entry = std::strcmp(ad.get_name(), ASYNC_EVENT_ENTRY_NAME) == 0;
	if(!is_root && !is_pid && !is_entry) {
		// We are not interested in parsing async events that are not
		// generated by our plugin.
		// This is not an error, it could happen when we have more than one
		// async plugin loaded.
		return true;
	}

	auto &tr = in.get_table_reader();

	if(is_root) {
		m_threads_table.iterate_entries(tr, [this, tr](const falcosecurity::table_entry &e) {
			int64_t tid;
			m_threads_field_tid.read_value(tr, e, tid);
			m_fuse_context.filler(m_fuse_context.buf,
			                      std::to_string(tid).c_str(),
			                      NULL,
			                      0,
			                      static_cast<enum fuse_fill_dir_flags>(0));
			return true;
		});
	}

	if(is_pid) {
		m_fuse_context.filler(m_fuse_context.buf,
		                      "comm",
		                      NULL,
		                      0,
		                      static_cast<enum fuse_fill_dir_flags>(0));
		m_fuse_context.filler(m_fuse_context.buf,
		                      "exe",
		                      NULL,
		                      0,
		                      static_cast<enum fuse_fill_dir_flags>(0));
		m_fuse_context.filler(m_fuse_context.buf,
		                      "cwd",
		                      NULL,
		                      0,
		                      static_cast<enum fuse_fill_dir_flags>(0));
	}

	if(is_entry) {
		uint32_t len = 0;
		char *field = (char *)dec.get_data(len);
		auto tid = evt.get_tid();
		try {
			auto tinfo = m_threads_table.get_entry(tr, (int64_t)tid);
			if(!strcmp(field, "comm")) {
				std::string comm = "";
				m_threads_field_comm.read_value(tr, tinfo, comm);
				memcpy(m_fuse_context.buf, comm.c_str(), comm.length() + 1);
			}
			if(!strcmp(field, "exe")) {
				std::string exe = "";
				m_threads_field_exe.read_value(tr, tinfo, exe);
				memcpy(m_fuse_context.buf, exe.c_str(), exe.length() + 1);
			}
			if(!strcmp(field, "cwd")) {
				std::string cwd = "";
				m_threads_field_cwd.read_value(tr, tinfo, cwd);
				if(cwd.empty()) {
					// If the cwd is empty, we set it to the root directory
					cwd = "/";
				}
				memcpy(m_fuse_context.buf, cwd.c_str(), cwd.length() + 1);
			}
		} catch(...) {
		}
	}

	m_fuse_context.done = true;
	m_fuse_context.m_cv.notify_all();
	return true;
}

bool my_plugin::parse_event(const falcosecurity::parse_event_input &in) {
	// NOTE: today in the libs framework, parsing errors are not logged
	auto &evt = in.get_event_reader();

	switch(evt.get_type()) {
	case PPME_ASYNCEVENT_E:
		return parse_async_event(in);
	default:
		SPDLOG_ERROR("received an unknown event type {}", int32_t(evt.get_type()));
		return false;
	}
}

FALCOSECURITY_PLUGIN_EVENT_PARSING(my_plugin);
